From 78521f3bb761cb309a61601fc24cc6bda5e77ddc Mon Sep 17 00:00:00 2001
From: Mohd Faraz <androiabledroid@gmail.com>
Date: Tue, 27 Aug 2024 21:30:31 +0530
Subject: [PATCH 1/5] minuitwrp: Clean up graphics_drm.cpp

Reference with: https://git.codelinaro.org/clo/la/platform/bootable/recovery/-/commit/76be34cb347d6b58b5bf3649c8033a1cb85559b4

Change-Id: I58754af24d264fc306f3c2abf398c81139dccf24
Signed-off-by: Mohd Faraz <androiabledroid@gmail.com>
---
 minuitwrp/graphics_drm.cpp | 309 +++++++++++++++++--------------------
 1 file changed, 141 insertions(+), 168 deletions(-)

diff --git a/minuitwrp/graphics_drm.cpp b/minuitwrp/graphics_drm.cpp
index a02613ff4..7a57d002b 100644
--- a/minuitwrp/graphics_drm.cpp
+++ b/minuitwrp/graphics_drm.cpp
@@ -14,18 +14,17 @@
  * limitations under the License.
  */
 
-#include <drm_fourcc.h>
 #include <fcntl.h>
 #include <poll.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/cdefs.h>
-#include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <unistd.h>
+
+#include <drm_fourcc.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
 
@@ -43,7 +42,7 @@ struct drm_surface {
 
 static drm_surface *drm_surfaces[2];
 static int current_buffer;
-static GRSurface *draw_buf = NULL;
+static GRSurface *draw_buf = nullptr;
 
 static drmModeCrtc *main_monitor_crtc;
 static drmModeConnector *main_monitor_connector;
@@ -55,59 +54,57 @@ static void drm_disable_crtc(int drm_fd, drmModeCrtc *crtc) {
         drmModeSetCrtc(drm_fd, crtc->crtc_id,
                        0, // fb_id
                        0, 0,  // x,y
-                       NULL,  // connectors
+                       nullptr,  // connectors
                        0,     // connector_count
-                       NULL); // mode
+                       nullptr); // mode
     }
 }
 
 static void drm_enable_crtc(int drm_fd, drmModeCrtc *crtc,
                             struct drm_surface *surface) {
-    int32_t ret;
-
-    ret = drmModeSetCrtc(drm_fd, crtc->crtc_id,
+    int32_t ret = drmModeSetCrtc(drm_fd, crtc->crtc_id,
                          surface->fb_id,
                          0, 0,  // x,y
                          &main_monitor_connector->connector_id,
                          1,  // connector_count
                          &main_monitor_crtc->mode);
 
-    if (ret)
+    if (ret) {
         printf("drmModeSetCrtc failed ret=%d\n", ret);
+    }
 }
 
 static void drm_blank(minui_backend* backend __unused, bool blank) {
-    if (blank)
+    if (blank) {
         drm_disable_crtc(drm_fd, main_monitor_crtc);
-    else
-        drm_enable_crtc(drm_fd, main_monitor_crtc,
-                        drm_surfaces[current_buffer]);
+    }
+    else {
+        drm_enable_crtc(drm_fd, main_monitor_crtc, drm_surfaces[current_buffer]);
+    }
 }
 
 static void drm_destroy_surface(struct drm_surface *surface) {
-    struct drm_gem_close gem_close;
-    int ret;
-
-    if(!surface)
-        return;
+    if(!surface) return;
 
-    if (surface->base.data)
-        munmap(surface->base.data,
-               surface->base.row_bytes * surface->base.height);
+    if (surface->base.data) {
+        munmap(surface->base.data, surface->base.row_bytes * surface->base.height);
+    }
 
     if (surface->fb_id) {
-        ret = drmModeRmFB(drm_fd, surface->fb_id);
-        if (ret)
+        int ret = drmModeRmFB(drm_fd, surface->fb_id);
+        if (ret) {
             printf("drmModeRmFB failed ret=%d\n", ret);
+        }
     }
 
     if (surface->handle) {
-        memset(&gem_close, 0, sizeof(gem_close));
+        drm_gem_close gem_close = {};
         gem_close.handle = surface->handle;
 
-        ret = drmIoctl(drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
-        if (ret)
+        int ret = drmIoctl(drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
+        if (ret) {
             printf("DRM_IOCTL_GEM_CLOSE failed ret=%d\n", ret);
+        }
     }
 
     free(surface);
@@ -133,16 +130,14 @@ static int drm_format_to_bpp(uint32_t format) {
 }
 
 static drm_surface *drm_create_surface(int width, int height) {
-    struct drm_surface *surface;
-    struct drm_mode_create_dumb create_dumb;
     uint32_t format;
     __u32 base_format;
     int ret;
 
-    surface = (struct drm_surface*)calloc(1, sizeof(*surface));
+    drm_surface* surface = static_cast<drm_surface*>(calloc(1, sizeof(*surface)));
     if (!surface) {
         printf("Can't allocate memory\n");
-        return NULL;
+        return nullptr;
     }
 
 #if defined(RECOVERY_ABGR)
@@ -167,7 +162,7 @@ static drm_surface *drm_create_surface(int width, int height) {
     printf("setting DRM_FORMAT_RGB565 and GGL_PIXEL_FORMAT_RGB_565\n");
 #endif
 
-    memset(&create_dumb, 0, sizeof(create_dumb));
+    drm_mode_create_dumb create_dumb = {};
     create_dumb.height = height;
     create_dumb.width = width;
     create_dumb.bpp = drm_format_to_bpp(format);
@@ -177,7 +172,7 @@ static drm_surface *drm_create_surface(int width, int height) {
     if (ret) {
         printf("DRM_IOCTL_MODE_CREATE_DUMB failed ret=%d\n",ret);
         drm_destroy_surface(surface);
-        return NULL;
+        return nullptr;
     }
     surface->handle = create_dumb.handle;
 
@@ -193,17 +188,16 @@ static drm_surface *drm_create_surface(int width, int height) {
     if (ret) {
         printf("drmModeAddFB2 failed ret=%d\n", ret);
         drm_destroy_surface(surface);
-        return NULL;
+        return nullptr;
     }
 
-    struct drm_mode_map_dumb map_dumb;
-    memset(&map_dumb, 0, sizeof(map_dumb));
+    struct drm_mode_map_dumb map_dumb = {};
     map_dumb.handle = create_dumb.handle;
     ret = drmIoctl(drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb);
     if (ret) {
         printf("DRM_IOCTL_MODE_MAP_DUMB failed ret=%d\n",ret);
         drm_destroy_surface(surface);
-        return NULL;;
+        return nullptr;;
     }
 
     surface->base.height = height;
@@ -212,14 +206,14 @@ static drm_surface *drm_create_surface(int width, int height) {
     surface->base.pixel_bytes = create_dumb.bpp / 8;
     surface->base.format = base_format;
     surface->base.data = (unsigned char*)
-                         mmap(NULL,
+                         mmap(nullptr,
                               surface->base.height * surface->base.row_bytes,
                               PROT_READ | PROT_WRITE, MAP_SHARED,
                               drm_fd, map_dumb.offset);
     if (surface->base.data == MAP_FAILED) {
         perror("mmap() failed");
         drm_destroy_surface(surface);
-        return NULL;
+        return nullptr;
     }
 
     return surface;
@@ -228,18 +222,18 @@ static drm_surface *drm_create_surface(int width, int height) {
 static drmModeCrtc *find_crtc_for_connector(int fd,
                             drmModeRes *resources,
                             drmModeConnector *connector) {
-    int i, j;
     drmModeEncoder *encoder;
-    int32_t crtc;
-
     /*
      * Find the encoder. If we already have one, just use it.
      */
-    if (connector->encoder_id)
+    if (connector->encoder_id) {
         encoder = drmModeGetEncoder(fd, connector->encoder_id);
-    else
-        encoder = NULL;
+    }
+    else {
+        encoder = nullptr;
+    }
 
+    int32_t crtc;
     if (encoder && encoder->crtc_id) {
         crtc = encoder->crtc_id;
         drmModeFreeEncoder(encoder);
@@ -250,11 +244,11 @@ static drmModeCrtc *find_crtc_for_connector(int fd,
      * Didn't find anything, try to find a crtc and encoder combo.
      */
     crtc = -1;
-    for (i = 0; i < connector->count_encoders; i++) {
+    for (int i = 0; i < connector->count_encoders; i++) {
         encoder = drmModeGetEncoder(fd, connector->encoders[i]);
 
         if (encoder) {
-            for (j = 0; j < resources->count_crtcs; j++) {
+            for (int j = 0; j < resources->count_crtcs; j++) {
                 if (!(encoder->possible_crtcs & (1 << j)))
                     continue;
                 crtc = resources->crtcs[j];
@@ -266,18 +260,14 @@ static drmModeCrtc *find_crtc_for_connector(int fd,
             }
         }
     }
-
-    return NULL;
+    return nullptr;
 }
 
 static drmModeConnector *find_used_connector_by_type(int fd,
                                  drmModeRes *resources,
                                  unsigned type) {
-    int i;
-    for (i = 0; i < resources->count_connectors; i++) {
-        drmModeConnector *connector;
-
-        connector = drmModeGetConnector(fd, resources->connectors[i]);
+    for (int i = 0; i < resources->count_connectors; i++) {
+        drmModeConnector* connector = drmModeGetConnector(fd, resources->connectors[i]);
         if (connector) {
             if ((connector->connector_type == type) &&
                     (connector->connection == DRM_MODE_CONNECTED) &&
@@ -287,16 +277,13 @@ static drmModeConnector *find_used_connector_by_type(int fd,
             drmModeFreeConnector(connector);
         }
     }
-    return NULL;
+    return nullptr;
 }
 
 static drmModeConnector *find_first_connected_connector(int fd,
                              drmModeRes *resources) {
-    int i;
-    for (i = 0; i < resources->count_connectors; i++) {
-        drmModeConnector *connector;
-
-        connector = drmModeGetConnector(fd, resources->connectors[i]);
+    for (int i = 0; i < resources->count_connectors; i++) {
+        drmModeConnector* connector = drmModeGetConnector(fd, resources->connectors[i]);
         if (connector) {
             if ((connector->count_modes > 0) &&
                     (connector->connection == DRM_MODE_CONNECTED))
@@ -305,13 +292,11 @@ static drmModeConnector *find_first_connected_connector(int fd,
             drmModeFreeConnector(connector);
         }
     }
-    return NULL;
+    return nullptr;
 }
 
 static drmModeConnector *find_main_monitor(int fd, drmModeRes *resources,
         uint32_t *mode_index) {
-    unsigned i = 0;
-    int modes;
     /* Look for LVDS/eDP/DSI connectors. Those are the main screens. */
     unsigned kConnectorPriority[] = {
         DRM_MODE_CONNECTOR_LVDS,
@@ -319,7 +304,8 @@ static drmModeConnector *find_main_monitor(int fd, drmModeRes *resources,
         DRM_MODE_CONNECTOR_DSI,
     };
 
-    drmModeConnector *main_monitor_connector = NULL;
+    drmModeConnector *main_monitor_connector = nullptr;
+    unsigned i = 0;
     do {
         main_monitor_connector = find_used_connector_by_type(fd,
                                          resources,
@@ -334,10 +320,10 @@ static drmModeConnector *find_main_monitor(int fd, drmModeRes *resources,
 
     /* If we still didn't find a connector, give up and return. */
     if (!main_monitor_connector)
-        return NULL;
+        return nullptr;
 
     *mode_index = 0;
-    for (modes = 0; modes < main_monitor_connector->count_modes; modes++) {
+    for (int modes = 0; modes < main_monitor_connector->count_modes; modes++) {
         if (main_monitor_connector->modes[modes].type &
                 DRM_MODE_TYPE_PREFERRED) {
             *mode_index = modes;
@@ -351,14 +337,9 @@ static drmModeConnector *find_main_monitor(int fd, drmModeRes *resources,
 static void disable_non_main_crtcs(int fd,
                     drmModeRes *resources,
                     drmModeCrtc* main_crtc) {
-    int i;
-    drmModeCrtc* crtc;
-
-    for (i = 0; i < resources->count_connectors; i++) {
-        drmModeConnector *connector;
-
-        connector = drmModeGetConnector(fd, resources->connectors[i]);
-        crtc = find_crtc_for_connector(fd, resources, connector);
+    for (int i = 0; i < resources->count_connectors; i++) {
+        drmModeConnector* connector = drmModeGetConnector(fd, resources->connectors[i]);
+        drmModeCrtc* crtc = find_crtc_for_connector(fd, resources, connector);
         if (crtc->crtc_id != main_crtc->crtc_id)
             drm_disable_crtc(fd, crtc);
         drmModeFreeCrtc(crtc);
@@ -366,120 +347,112 @@ static void disable_non_main_crtcs(int fd,
 }
 
 static GRSurface* drm_init(minui_backend* backend __unused) {
-    drmModeRes *res = NULL;
-    uint32_t selected_mode;
-    char *dev_name;
-    int width, height;
-    int ret, i;
-
-    /* Consider DRM devices in order. */
-    for (i = 0; i < DRM_MAX_MINOR; i++) {
-        uint64_t cap = 0;
-
-        ret = asprintf(&dev_name, DRM_DEV_NAME, DRM_DIR_NAME, i);
-        if (ret < 0)
-            continue;
-
-        drm_fd = open(dev_name, O_RDWR, 0);
-        free(dev_name);
-        if (drm_fd < 0)
-            continue;
-
-        /* We need dumb buffers. */
-        ret = drmGetCap(drm_fd, DRM_CAP_DUMB_BUFFER, &cap);
-        if (ret || cap == 0) {
-            close(drm_fd);
-            continue;
-        }
+  drmModeRes* res = nullptr;
 
-        res = drmModeGetResources(drm_fd);
-        if (!res) {
-            close(drm_fd);
-            continue;
-        }
+  /* Consider DRM devices in order. */
+  for (int i = 0; i < DRM_MAX_MINOR; i++) {
+    char* dev_name;
+    int ret = asprintf(&dev_name, DRM_DEV_NAME, DRM_DIR_NAME, i);
+    if (ret < 0) continue;
 
-        /* Use this device if it has at least one connected monitor. */
-        if (res->count_crtcs > 0 && res->count_connectors > 0)
-            if (find_first_connected_connector(drm_fd, res))
-                break;
+    drm_fd = open(dev_name, O_RDWR, 0);
+    free(dev_name);
+    if (drm_fd < 0) continue;
 
-        drmModeFreeResources(res);
-        close(drm_fd);
-        res = NULL;
-    }
+    uint64_t cap = 0;
+    /* We need dumb buffers. */
+    ret = drmGetCap(drm_fd, DRM_CAP_DUMB_BUFFER, &cap);
+    if (ret || cap == 0) {
+      close(drm_fd);
+      continue;
 
-    if (drm_fd < 0 || res == NULL) {
-        perror("cannot find/open a drm device");
-        return NULL;
+    }
+    res = drmModeGetResources(drm_fd);
+    if (!res) {
+      close(drm_fd);
+      continue;
     }
 
-    main_monitor_connector = find_main_monitor(drm_fd,
-            res, &selected_mode);
-
-    if (!main_monitor_connector) {
-        printf("main_monitor_connector not found\n");
-        drmModeFreeResources(res);
-        close(drm_fd);
-        return NULL;
+    /* Use this device if it has at least one connected monitor. */
+    if (res->count_crtcs > 0 && res->count_connectors > 0) {
+      if (find_first_connected_connector(drm_fd, res)) break;
     }
 
-    main_monitor_crtc = find_crtc_for_connector(drm_fd, res,
-                                                main_monitor_connector);
+    drmModeFreeResources(res);
+    close(drm_fd);
+    res = nullptr;
+  }
 
-    if (!main_monitor_crtc) {
-        printf("main_monitor_crtc not found\n");
-        drmModeFreeResources(res);
-        close(drm_fd);
-        return NULL;
-    }
+  if (drm_fd < 0 || res == nullptr) {
+    perror("cannot find/open a drm device");
+    return nullptr;
+  }
 
-    disable_non_main_crtcs(drm_fd,
-                           res, main_monitor_crtc);
+  uint32_t selected_mode;
+  main_monitor_connector = find_main_monitor(drm_fd, res, &selected_mode);
 
-    main_monitor_crtc->mode = main_monitor_connector->modes[selected_mode];
+  if (!main_monitor_connector) {
+    printf("main_monitor_connector not found\n");
+    drmModeFreeResources(res);
+    close(drm_fd);
+    return nullptr;
+  }
 
-    width = main_monitor_crtc->mode.hdisplay;
-    height = main_monitor_crtc->mode.vdisplay;
+  main_monitor_crtc = find_crtc_for_connector(drm_fd, res, main_monitor_connector);
 
+  if (!main_monitor_crtc) {
+    printf("main_monitor_crtc not found\n");
     drmModeFreeResources(res);
+    close(drm_fd);
+    return nullptr;
+  }
 
-    drm_surfaces[0] = drm_create_surface(width, height);
-    drm_surfaces[1] = drm_create_surface(width, height);
-    if (!drm_surfaces[0] || !drm_surfaces[1]) {
-        drm_destroy_surface(drm_surfaces[0]);
-        drm_destroy_surface(drm_surfaces[1]);
-        drmModeFreeResources(res);
-        close(drm_fd);
-        return NULL;
-    }
+  disable_non_main_crtcs(drm_fd, res, main_monitor_crtc);
 
-    draw_buf = (GRSurface *)malloc(sizeof(GRSurface));
-    if (!draw_buf) {
-        printf("failed to alloc draw_buf\n");
-        drm_destroy_surface(drm_surfaces[0]);
-        drm_destroy_surface(drm_surfaces[1]);
-        drmModeFreeResources(res);
-        close(drm_fd);
-        return NULL;
-    }
+  main_monitor_crtc->mode = main_monitor_connector->modes[selected_mode];
 
-    memcpy(draw_buf, &drm_surfaces[0]->base, sizeof(GRSurface));
-    draw_buf->data = (unsigned char *)calloc(draw_buf->height * draw_buf->row_bytes, 1);
-    if (!draw_buf->data) {
-        printf("failed to alloc draw_buf surface\n");
-        free(draw_buf);
-        drm_destroy_surface(drm_surfaces[0]);
-        drm_destroy_surface(drm_surfaces[1]);
-        drmModeFreeResources(res);
-        close(drm_fd);
-        return NULL;
-    }
+  int width = main_monitor_crtc->mode.hdisplay;
+  int height = main_monitor_crtc->mode.vdisplay;
+
+  drmModeFreeResources(res);
 
-    current_buffer = 0;
+  drm_surfaces[0] = drm_create_surface(width, height);
+  drm_surfaces[1] = drm_create_surface(width, height);
+  if (!drm_surfaces[0] || !drm_surfaces[1]) {
+    drm_destroy_surface(drm_surfaces[0]);
+    drm_destroy_surface(drm_surfaces[1]);
+    drmModeFreeResources(res);
+    close(drm_fd);
+    return nullptr;
+  }
 
-    drm_enable_crtc(drm_fd, main_monitor_crtc, drm_surfaces[1]);
+  draw_buf = (GRSurface *)malloc(sizeof(GRSurface));
+  if (!draw_buf) {
+    printf("failed to alloc draw_buf\n");
+    drm_destroy_surface(drm_surfaces[0]);
+    drm_destroy_surface(drm_surfaces[1]);
+    drmModeFreeResources(res);
+    close(drm_fd);
+    return nullptr;
+  }
+
+  memcpy(draw_buf, &drm_surfaces[0]->base, sizeof(GRSurface));
+  draw_buf->data = (unsigned char *)calloc(draw_buf->height * draw_buf->row_bytes, 1);
+  if (!draw_buf->data) {
+    printf("failed to alloc draw_buf surface\n");
+    free(draw_buf);
+    drm_destroy_surface(drm_surfaces[0]);
+    drm_destroy_surface(drm_surfaces[1]);
+    drmModeFreeResources(res);
+    close(drm_fd);
+    return nullptr;
+  }
 
-    return draw_buf;
+  current_buffer = 0;
+
+  drm_enable_crtc(drm_fd, main_monitor_crtc, drm_surfaces[1]);
+
+  return draw_buf;
 }
 
 static void page_flip_complete(__unused int fd,
-- 
2.47.1


From d3ea5371b1f0b2c3abb07a60ece3f56e48294e71 Mon Sep 17 00:00:00 2001
From: Samantha Tran <samtran@codeaurora.org>
Date: Wed, 4 Apr 2018 22:24:34 -0700
Subject: [PATCH 2/5] minuitwrp: implement atomic commit for recovery charger

Change setCrtc calls to atomic commits. Establish pipeline
and split plane to display charger image.

CRs-Fixed: 2221005
Change-Id: I0ca9be1a65b6889afa7e16016b7094ad90930d57
Signed-off-by: Samantha Tran <samtran@codeaurora.org>
Signed-off-by: Mohd Faraz <androiabledroid@gmail.com>
---
 minuitwrp/graphics_drm.cpp | 429 +++++++++++++++++++++++++++++++++----
 1 file changed, 388 insertions(+), 41 deletions(-)

diff --git a/minuitwrp/graphics_drm.cpp b/minuitwrp/graphics_drm.cpp
index 7a57d002b..1a6a798e7 100644
--- a/minuitwrp/graphics_drm.cpp
+++ b/minuitwrp/graphics_drm.cpp
@@ -14,6 +14,33 @@
  * limitations under the License.
  */
 
+/*
+ * DRM based mode setting test program
+ * Copyright 2008 Tungsten Graphics
+ *   Jakob Bornecrantz <jakob@tungstengraphics.com>
+ * Copyright 2008 Intel Corporation
+ *   Jesse Barnes <jesse.barnes@intel.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
 #include <fcntl.h>
 #include <poll.h>
 #include <stdbool.h>
@@ -40,6 +67,27 @@ struct drm_surface {
     uint32_t handle;
 };
 
+#define NUM_MAIN 1
+#define NUM_PLANES 2
+
+struct Crtc {
+  drmModeObjectProperties *props;
+  drmModePropertyRes **props_info;
+  uint32_t mode_blob_id;
+};
+
+struct Connector {
+  drmModeObjectProperties *props;
+  drmModePropertyRes **props_info;
+};
+
+struct Plane {
+  drmModePlane *plane;
+  drmModeObjectProperties *props;
+  drmModePropertyRes ** props_info;
+};
+
+
 static drm_surface *drm_surfaces[2];
 static int current_buffer;
 static GRSurface *draw_buf = nullptr;
@@ -49,38 +97,229 @@ static drmModeConnector *main_monitor_connector;
 
 static int drm_fd = -1;
 
-static void drm_disable_crtc(int drm_fd, drmModeCrtc *crtc) {
-    if (crtc) {
-        drmModeSetCrtc(drm_fd, crtc->crtc_id,
-                       0, // fb_id
-                       0, 0,  // x,y
-                       nullptr,  // connectors
-                       0,     // connector_count
-                       nullptr); // mode
+bool current_blank_state = true;
+int fb_prop_id;
+struct Crtc crtc_res;
+struct Connector conn_res;
+struct Plane plane_res[NUM_PLANES];
+
+enum screen_side{Left, Right};
+
+#define find_prop_id(_res, type, Type, obj_id, prop_name, prop_id)    \
+  do {                                                                \
+    int j = 0;                                                        \
+    int prop_count = 0;                                               \
+    struct Type *obj = NULL;                                          \
+    obj = (_res);                                                     \
+    if (!obj || main_monitor_##type->type##_id != (obj_id)){          \
+      prop_id = 0;                                                    \
+      break;                                                          \
+    }                                                                 \
+    prop_count = (int)obj->props->count_props;                        \
+    for (j = 0; j < prop_count; ++j)                                  \
+      if (!strcmp(obj->props_info[j]->name, (prop_name)))             \
+        break;                                                        \
+    (prop_id) = (j == prop_count)?                                    \
+      0 : obj->props_info[j]->prop_id;                                \
+  } while (0)
+
+#define add_prop(res, type, Type, id, id_name, id_val) \
+  find_prop_id(res, type, Type, id, id_name, prop_id); \
+  if (prop_id)                                         \
+    drmModeAtomicAddProperty(atomic_req, id, prop_id, id_val);
+
+static int find_plane_prop_id(uint32_t obj_id, const char *prop_name,
+                              Plane *plane_res) {
+  int i, j = 0;
+  int prop_count = 0;
+  struct Plane *obj = NULL;
+
+  for (i = 0; i < NUM_PLANES; ++i) {
+    obj = &plane_res[i];
+    if (!obj || obj->plane->plane_id != obj_id)
+      continue;
+    prop_count = (int)obj->props->count_props;
+    for (j = 0; j < prop_count; ++j)
+      if (!strcmp(obj->props_info[j]->name, prop_name))
+       return obj->props_info[j]->prop_id;
+    break;
+  }
+
+  return 0;
+}
+
+static int atomic_add_prop_to_plane(Plane *plane_res, drmModeAtomicReq *req,
+                                    uint32_t obj_id, const char *prop_name,
+                                    uint64_t value) {
+  uint32_t prop_id;
+
+  prop_id = find_plane_prop_id(obj_id, prop_name, plane_res);
+  if (prop_id == 0) {
+    printf("Could not find obj_id = %d\n", obj_id);
+    return -EINVAL;
+  }
+
+  if (drmModeAtomicAddProperty(req, obj_id, prop_id, value) < 0) {
+    printf("Could not add prop_id = %d for obj_id %d\n",
+            prop_id, obj_id);
+    return -EINVAL;
+  }
+
+  return 0;
+}
+
+
+
+static int atomic_populate_plane(int plane, drmModeAtomicReqPtr atomic_req) {
+  uint32_t src_x, src_y, src_w, src_h;
+  uint32_t crtc_x, crtc_y, crtc_w, crtc_h;
+  int width = main_monitor_crtc->mode.hdisplay;
+  int height = main_monitor_crtc->mode.vdisplay;
+
+  src_y = 0;
+  src_w = width/2;
+  src_h =  height;
+  crtc_y = 0;
+  crtc_w = width/2;
+  crtc_h = height;
+
+  if (plane == Left) {
+    src_x = 0;
+    crtc_x = 0;
+  } else {
+    src_x = width/2;
+    crtc_x = width/2;
+  }
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "FB_ID",
+                               drm_surfaces[current_buffer]->fb_id))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "SRC_X", src_x << 16))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "SRC_Y", src_y << 16))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "SRC_W", src_w << 16))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "SRC_H", src_h << 16))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "CRTC_X", crtc_x))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "CRTC_Y", crtc_y))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "CRTC_W", crtc_w))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "CRTC_H", crtc_h))
+    return -EINVAL;
+
+  if (atomic_add_prop_to_plane(plane_res, atomic_req,
+                               plane_res[plane].plane->plane_id, "CRTC_ID",
+                               main_monitor_crtc->crtc_id))
+    return -EINVAL;
+
+  return 0;
+}
+
+static int teardown_pipeline(drmModeAtomicReqPtr atomic_req) {
+  uint32_t prop_id;
+  int i, ret;
+
+  /* During suspend, tear down pipeline */
+  add_prop(&conn_res, connector, Connector, main_monitor_connector->connector_id, "CRTC_ID", 0);
+  add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "MODE_ID", 0);
+  add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "ACTIVE", 0);
+
+  for(i = 0; i < NUM_PLANES; i++) {
+    ret = atomic_add_prop_to_plane(plane_res, atomic_req,
+                                   plane_res[i].plane->plane_id, "CRTC_ID", 0);
+    if (ret < 0) {
+      printf("Failed to tear down plane %d\n", i);
+      return ret;
+    }
+
+    if (drmModeAtomicAddProperty(atomic_req, plane_res[i].plane->plane_id, fb_prop_id, 0) < 0) {
+      printf("Failed to add property for plane_id=%d\n", plane_res[i].plane->plane_id);
+      return -EINVAL;
     }
+  }
+
+  return 0;
 }
 
-static void drm_enable_crtc(int drm_fd, drmModeCrtc *crtc,
-                            struct drm_surface *surface) {
-    int32_t ret = drmModeSetCrtc(drm_fd, crtc->crtc_id,
-                         surface->fb_id,
-                         0, 0,  // x,y
-                         &main_monitor_connector->connector_id,
-                         1,  // connector_count
-                         &main_monitor_crtc->mode);
+static int drm_disable_crtc(drmModeAtomicReqPtr atomic_req) {
+  return teardown_pipeline(atomic_req);
+}
 
-    if (ret) {
-        printf("drmModeSetCrtc failed ret=%d\n", ret);
+static int setup_pipeline(drmModeAtomicReqPtr atomic_req) {
+  uint32_t prop_id;
+  int i, ret;
+
+  for(i = 0; i < NUM_PLANES; i++) {
+    add_prop(&conn_res, connector, Connector, main_monitor_connector->connector_id,
+         "CRTC_ID", main_monitor_crtc->crtc_id);
+    add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "MODE_ID", crtc_res.mode_blob_id);
+    add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "ACTIVE", 1);
+  }
+
+  /* Setup planes */
+  for(i = 0; i < NUM_PLANES; i++) {
+    ret = atomic_populate_plane(i, atomic_req);
+    if (ret < 0) {
+      printf("Error populating plane_id = %d\n", plane_res[i].plane->plane_id);
+      return ret;
     }
+  }
+
+  return 0;
+
+}
+static int drm_enable_crtc(drmModeAtomicReqPtr atomic_req) {
+  return setup_pipeline(atomic_req);
 }
 
 static void drm_blank(minui_backend* backend __unused, bool blank) {
-    if (blank) {
-        drm_disable_crtc(drm_fd, main_monitor_crtc);
-    }
-    else {
-        drm_enable_crtc(drm_fd, main_monitor_crtc, drm_surfaces[current_buffer]);
-    }
+  int ret = 0;
+
+  if (blank == current_blank_state)
+    return;
+
+  drmModeAtomicReqPtr atomic_req = drmModeAtomicAlloc();
+  if (!atomic_req) {
+     printf("Atomic Alloc failed\n");
+     return;
+  }
+
+  if (blank)
+    ret = drm_disable_crtc(atomic_req);
+  else
+    ret = drm_enable_crtc(atomic_req);
+
+  if (!ret)
+    ret = drmModeAtomicCommit(drm_fd, atomic_req, DRM_MODE_ATOMIC_ALLOW_MODESET, NULL);
+
+  if (!ret) {
+    printf("Atomic Commit failed, rc = %d\n", ret);
+    current_blank_state = blank;
+  }
+
+  drmModeAtomicFree(atomic_req);
+
 }
 
 static void drm_destroy_surface(struct drm_surface *surface) {
@@ -337,13 +576,55 @@ static drmModeConnector *find_main_monitor(int fd, drmModeRes *resources,
 static void disable_non_main_crtcs(int fd,
                     drmModeRes *resources,
                     drmModeCrtc* main_crtc) {
-    for (int i = 0; i < resources->count_connectors; i++) {
-        drmModeConnector* connector = drmModeGetConnector(fd, resources->connectors[i]);
-        drmModeCrtc* crtc = find_crtc_for_connector(fd, resources, connector);
-        if (crtc->crtc_id != main_crtc->crtc_id)
-            drm_disable_crtc(fd, crtc);
-        drmModeFreeCrtc(crtc);
+  uint32_t prop_id;
+  drmModeAtomicReqPtr atomic_req = drmModeAtomicAlloc();
+  for (int i = 0; i < resources->count_connectors; i++) {
+    drmModeConnector* connector = drmModeGetConnector(fd, resources->connectors[i]);
+    drmModeCrtc* crtc = find_crtc_for_connector(fd, resources, connector);
+    if (crtc->crtc_id != main_crtc->crtc_id) {
+      // Switching to atomic commit. Given only crtc, we can only set ACTIVE = 0
+      // to disable any Nonmain CRTCs
+      find_prop_id(&crtc_res, crtc, Crtc, crtc->crtc_id, "ACTIVE", prop_id);
+      if (prop_id == 0)
+        return;
+
+      if (drmModeAtomicAddProperty(atomic_req, main_monitor_crtc->crtc_id, prop_id, 0) < 0)
+        return;
+
     }
+    drmModeFreeCrtc(crtc);
+  }
+  if (!drmModeAtomicCommit(drm_fd, atomic_req,DRM_MODE_ATOMIC_ALLOW_MODESET, NULL))
+    printf("Atomic Commit failed in DisableNonMainCrtcs\n");
+
+  drmModeAtomicFree(atomic_req);
+}
+
+static void update_plane_fb() {
+  int i;
+
+  /* Set atomic req */
+  drmModeAtomicReqPtr atomic_req = drmModeAtomicAlloc();
+  if (!atomic_req) {
+     printf("Atomic Alloc failed. Could not update fb_id\n");
+     return;
+  }
+
+  /* Add property */
+  for(i = 0; i < NUM_PLANES; i++)
+    drmModeAtomicAddProperty(atomic_req, plane_res[i].plane->plane_id,
+                             fb_prop_id, drm_surfaces[current_buffer]->fb_id);
+
+  /* Commit changes */
+  int32_t ret;
+  ret = drmModeAtomicCommit(drm_fd, atomic_req,
+                 DRM_MODE_ATOMIC_ALLOW_MODESET, NULL);
+
+  drmModeAtomicFree(atomic_req);
+
+  if (ret)
+    printf("Atomic commit failed ret=%d\n", ret);
+
 }
 
 static GRSurface* drm_init(minui_backend* backend __unused) {
@@ -450,7 +731,80 @@ static GRSurface* drm_init(minui_backend* backend __unused) {
 
   current_buffer = 0;
 
-  drm_enable_crtc(drm_fd, main_monitor_crtc, drm_surfaces[1]);
+ /* Get possible plane_ids */
+  drmModePlaneRes *plane_options = drmModeGetPlaneResources(drm_fd);
+  if (!plane_options)
+    return NULL;
+
+  drmSetClientCap(drm_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+  drmSetClientCap(drm_fd, DRM_CLIENT_CAP_ATOMIC, 1);
+
+  /* Set crtc resources */
+  crtc_res.props = drmModeObjectGetProperties(drm_fd,
+                      main_monitor_crtc->crtc_id,
+                      DRM_MODE_OBJECT_CRTC);
+  crtc_res.props_info = static_cast<drmModePropertyRes **>
+                           (calloc(crtc_res.props->count_props,
+                           sizeof(crtc_res.props_info)));
+  if (!crtc_res.props || !crtc_res.props_info)
+    return NULL;
+  else
+    for (int j = 0; j < (int)crtc_res.props->count_props; ++j)
+      crtc_res.props_info[j] = drmModeGetProperty(drm_fd,
+                                   crtc_res.props->props[j]);
+
+  /* Set connector resources */
+  conn_res.props = drmModeObjectGetProperties(drm_fd,
+                     main_monitor_connector->connector_id,
+                     DRM_MODE_OBJECT_CONNECTOR);
+  conn_res.props_info = static_cast<drmModePropertyRes **>
+                         (calloc(conn_res.props->count_props,
+                         sizeof(conn_res.props_info)));
+  if(!conn_res.props || !conn_res.props_info)
+    return NULL;
+  else
+    for (int j = 0; j < (int)conn_res.props->count_props; ++j)
+      conn_res.props_info[j] = drmModeGetProperty(drm_fd,
+                                 conn_res.props->props[j]);
+
+  /* Set plane resources */
+  for(int i = 0; i < NUM_PLANES; ++i) {
+    plane_res[i].plane = drmModeGetPlane(drm_fd, plane_options->planes[i]);
+    if (!plane_res[i].plane)
+      return NULL;
+  }
+
+  for (int i = 0; i < NUM_PLANES; ++i) {
+    struct Plane *obj = &plane_res[i];
+    unsigned int j;
+    obj->props = drmModeObjectGetProperties(drm_fd, obj->plane->plane_id,
+                    DRM_MODE_OBJECT_PLANE);
+    if (!obj->props)
+      continue;
+    obj->props_info = static_cast<drmModePropertyRes **>
+                         (calloc(obj->props->count_props, sizeof(*obj->props_info)));
+    if (!obj->props_info)
+      continue;
+    for (j = 0; j < obj->props->count_props; ++j)
+      obj->props_info[j] = drmModeGetProperty(drm_fd, obj->props->props[j]);
+  }
+
+  drmModeFreePlaneResources(plane_options);
+  plane_options = NULL;
+
+  /* Setup pipe and blob_id */
+  if (drmModeCreatePropertyBlob(drm_fd, &main_monitor_crtc->mode, sizeof(drmModeModeInfo),
+      &crtc_res.mode_blob_id)) {
+    printf("failed to create mode blob\n");
+    return NULL;
+  }
+
+  /* Save fb_prop_id*/
+  uint32_t prop_id;
+  prop_id = find_plane_prop_id(plane_res[0].plane->plane_id, "FB_ID", plane_res);
+  fb_prop_id = prop_id;
+
+  drm_blank(nullptr, false);
 
   return draw_buf;
 }
@@ -467,13 +821,7 @@ static GRSurface* drm_flip(minui_backend* backend __unused) {
     bool ongoing_flip = true;
     memcpy(drm_surfaces[current_buffer]->base.data,
             draw_buf->data, draw_buf->height * draw_buf->row_bytes);
-
-
-    if (drmModePageFlip(drm_fd, main_monitor_crtc->crtc_id,
-                          drm_surfaces[current_buffer]->fb_id, DRM_MODE_PAGE_FLIP_EVENT, &ongoing_flip)) {
-        printf("Failed to drmModePageFlip");
-        return nullptr;
-    }
+    update_plane_fb();
 
     while (ongoing_flip) {
         struct pollfd fds = {
@@ -502,11 +850,10 @@ static GRSurface* drm_flip(minui_backend* backend __unused) {
 }
 
 static void drm_exit(minui_backend* backend __unused) {
-    drm_disable_crtc(drm_fd, main_monitor_crtc);
+    drm_blank(nullptr, true);
+    drmModeDestroyPropertyBlob(drm_fd, crtc_res.mode_blob_id);
     drm_destroy_surface(drm_surfaces[0]);
     drm_destroy_surface(drm_surfaces[1]);
-    drmModeFreeCrtc(main_monitor_crtc);
-    drmModeFreeConnector(main_monitor_connector);
     close(drm_fd);
     drm_fd = -1;
 }
-- 
2.47.1


From dca97310d66fa20841840e614ce890674471ebaf Mon Sep 17 00:00:00 2001
From: Mohd Faraz <androiabledroid@gmail.com>
Date: Thu, 29 Aug 2024 01:40:31 +0530
Subject: [PATCH 3/5] minuitwrp: polling is not required now in flip

Change-Id: I2eb96374101928729b347517309b0ebff0d0ec9e
Signed-off-by: Mohd Faraz <androiabledroid@gmail.com>
---
 minuitwrp/graphics_drm.cpp | 42 +++++---------------------------------
 1 file changed, 5 insertions(+), 37 deletions(-)

diff --git a/minuitwrp/graphics_drm.cpp b/minuitwrp/graphics_drm.cpp
index 1a6a798e7..afe4e9da6 100644
--- a/minuitwrp/graphics_drm.cpp
+++ b/minuitwrp/graphics_drm.cpp
@@ -97,11 +97,11 @@ static drmModeConnector *main_monitor_connector;
 
 static int drm_fd = -1;
 
-bool current_blank_state = true;
-int fb_prop_id;
-struct Crtc crtc_res;
-struct Connector conn_res;
-struct Plane plane_res[NUM_PLANES];
+static bool current_blank_state = true;
+static int fb_prop_id;
+static struct Crtc crtc_res;
+static struct Connector conn_res;
+static struct Plane plane_res[NUM_PLANES];
 
 enum screen_side{Left, Right};
 
@@ -809,42 +809,10 @@ static GRSurface* drm_init(minui_backend* backend __unused) {
   return draw_buf;
 }
 
-static void page_flip_complete(__unused int fd,
-                               __unused unsigned int sequence,
-                               __unused unsigned int tv_sec,
-                               __unused unsigned int tv_usec,
-                               void *user_data) {
-  *static_cast<bool*>(user_data) = false;
-}
-
 static GRSurface* drm_flip(minui_backend* backend __unused) {
-    bool ongoing_flip = true;
     memcpy(drm_surfaces[current_buffer]->base.data,
             draw_buf->data, draw_buf->height * draw_buf->row_bytes);
     update_plane_fb();
-
-    while (ongoing_flip) {
-        struct pollfd fds = {
-            .fd = drm_fd,
-            .events = POLLIN
-        };
-
-        if (poll(&fds, 1, -1) == -1 || !(fds.revents & POLLIN)) {
-            perror("Failed to poll() on drm fd");
-            break;
-        }
-
-        drmEventContext evctx = {
-            .version = DRM_EVENT_CONTEXT_VERSION,
-            .page_flip_handler = page_flip_complete
-        };
-
-        if (drmHandleEvent(drm_fd, &evctx) != 0) {
-            perror("Failed to drmHandleEvent");
-            break;
-        }
-    }
-
     current_buffer = 1 - current_buffer;
     return draw_buf;
 }
-- 
2.47.1


From 4ad20b700567c634f3b61fded9c57c74c88cd802 Mon Sep 17 00:00:00 2001
From: Mohd Faraz <androiabledroid@gmail.com>
Date: Wed, 28 Aug 2024 11:59:17 +0530
Subject: [PATCH 4/5] minuitwrp: import layer topology support from CLO

This is a squash of the following commits.

  Author: David Ng <dave@codeaurora.org>
  Date:   Thu Sep 13 18:45:52 2018 -0700

      minui: Handle NULL return conditions and potential beyond bound access

      Fix NULL return handling in minui for DRM scenario.

      CRs-Fixed: 2315166
      Change-Id: Ifa9f5d055a0cbcfadd505edc1a5f13b97605c92d

  Author: Uday Kiran Pichika <pichika@codeaurora.org>
  Date:   Mon Nov 5 14:19:09 2018 +0530

      minui: Add support for low resolution display topologies

      - Add a single layer mixer topology to cover low resolution
        display framebuffer e.g. FHD, FHD+. Display is cropped
        in absence of this topology.

      CRs-Fixed: 2324756
      Change-Id: I119186b8eace8b03ca044a780e1b98d2a7bb08cc

  Author: Anjaneya Prasad Musunuri <aprasad@codeaurora.org>
  Date:   Fri Nov 30 10:33:45 2018 +0530

      minui: Set client cap properties for planes before accessing them

      Set the client cap properties for planes before
      getting plane_resources.

      Change-Id: I08371b44bc34c95d7a97a4808cc8abcb6e063f0e
      CRs-Fixed: 2354871

  Author: Amine Najahi <anajahi@codeaurora.org>
  Date:   Tue Jul 7 18:06:59 2020 -0400

      Add support for 4 layer mixer staging logic

      Currently plane staging logic assumes that only
      2 planes (L/R) are required to drive the display.
      When a 4LM topology is used, 4 adjacent planes are
      needed to cover wider display resolutions.

      This changes offsets plane src_x and dest_x coordinates
      based on plane index and removes L/R assumption. It also
      adds 4LM and VDC based topologies.

      CRs-Fixed: 2672665
      Test: boot-up test on 2LM and 4LM topologies

      Change-Id: If33e9b22b5545e2187ab614eed390dfe09af56a9

  Author: Prashant Beniwal <pbeniw@codeaurora.org>
  Date:   Thu Oct 29 08:24:41 2020 +0530

      Program required properties for 4 layer mixer

      Legacy KMS driver expects planes to have different z-order
      when staging them across two layer mixer pairs.

      This change increments the plane z-order and programs
      "zpos" optional property.

      This change also adds missing connector-crtc association
      property for the atomic commit required for driver to
      recognize whether its a quadpipe topology or not.

      CRs-Fixed: 2753034
      Test: boot-up test on 2LM and 4LM topologies

      Change-Id: Icb941ca689b770c529694862925aaedc64cb8afc

Change-Id: I0172829fbaa70b0052cf4fdc3a51bfef841195ab
Signed-off-by: Mohd Faraz <androiabledroid@gmail.com>
---
 minuitwrp/graphics_drm.cpp | 157 +++++++++++++++++++++++++++++--------
 1 file changed, 124 insertions(+), 33 deletions(-)

diff --git a/minuitwrp/graphics_drm.cpp b/minuitwrp/graphics_drm.cpp
index afe4e9da6..5628dc415 100644
--- a/minuitwrp/graphics_drm.cpp
+++ b/minuitwrp/graphics_drm.cpp
@@ -51,9 +51,11 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#include <string>
 #include <drm_fourcc.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
+#include <sstream>
 
 #include "minuitwrp/minui.h"
 #include "graphics.h"
@@ -68,7 +70,8 @@ struct drm_surface {
 };
 
 #define NUM_MAIN 1
-#define NUM_PLANES 2
+#define NUM_PLANES 4
+#define DEFAULT_NUM_LMS 2
 
 struct Crtc {
   drmModeObjectProperties *props;
@@ -102,8 +105,7 @@ static int fb_prop_id;
 static struct Crtc crtc_res;
 static struct Connector conn_res;
 static struct Plane plane_res[NUM_PLANES];
-
-enum screen_side{Left, Right};
+static uint32_t number_of_lms = DEFAULT_NUM_LMS;
 
 #define find_prop_id(_res, type, Type, obj_id, prop_name, prop_id)    \
   do {                                                                \
@@ -128,6 +130,68 @@ enum screen_side{Left, Right};
   if (prop_id)                                         \
     drmModeAtomicAddProperty(atomic_req, id, prop_id, id_val);
 
+/**
+ * enum sde_rm_topology_name - HW resource use case in use by connector
+ * @SDE_RM_TOPOLOGY_NONE:                 No topology in use currently
+ * @SDE_RM_TOPOLOGY_SINGLEPIPE:           1 LM, 1 PP, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_SINGLEPIPE_DSC:       1 LM, 1 DSC, 1 PP, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_SINGLEPIPE_VDC:       1 LM, 1 VDC, 1 PP, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_DUALPIPE:             2 LM, 2 PP, 2 INTF/WB
+ * @SDE_RM_TOPOLOGY_DUALPIPE_DSC:         2 LM, 2 DSC, 2 PP, 2 INTF/WB
+ * @SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE:     2 LM, 2 PP, 3DMux, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE_DSC: 2 LM, 2 PP, 3DMux, 1 DSC, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE_VDC: 2 LM, 2 PP, 3DMux, 1 VDC, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_DUALPIPE_DSCMERGE:    2 LM, 2 PP, 2 DSC Merge, 1 INTF/WB
+ * @SDE_RM_TOPOLOGY_PPSPLIT:              1 LM, 2 PPs, 2 INTF/WB
+ * @SDE_RM_TOPOLOGY_QUADPIPE_3DMERGE      4 LM, 4 PP, 3DMux, 2 INTF
+ * @SDE_RM_TOPOLOGY_QUADPIPE_3DMERGE_DSC  4 LM, 4 PP, 3DMux, 3 DSC, 2 INTF
+ * @SDE_RM_TOPOLOGY_QUADPIPE_DSCMERE      4 LM, 4 PP, 4 DSC Merge, 2 INTF
+ * @SDE_RM_TOPOLOGY_QUADPIPE_DSC4HSMERGE  4 LM, 4 PP, 4 DSC Merge, 1 INTF
+ */
+
+static uint32_t get_lm_number(const std::string &topology) {
+  if (topology == "sde_singlepipe") return 1;
+  if (topology == "sde_singlepipe_dsc") return 1;
+  if (topology == "sde_singlepipe_vdc") return 1;
+  if (topology == "sde_dualpipe") return 2;
+  if (topology == "sde_dualpipe_dsc") return 2;
+  if (topology == "sde_dualpipe_vdc") return 2;
+  if (topology == "sde_dualpipemerge") return 2;
+  if (topology == "sde_dualpipemerge_dsc") return 2;
+  if (topology == "sde_dualpipemerge_vdc") return 2;
+  if (topology == "sde_dualpipe_dscmerge") return 2;
+  if (topology == "sde_ppsplit") return 1;
+  if (topology == "sde_quadpipemerge") return 4;
+  if (topology == "sde_quadpipe_3dmerge_dsc") return 4;
+  if (topology == "sde_quadpipe_dscmerge") return 4;
+  if (topology == "sde_quadpipe_dsc4hsmerge") return 4;
+  return DEFAULT_NUM_LMS;
+}
+
+static uint32_t get_topology_lm_number(int fd, uint32_t blob_id) {
+  uint32_t num_lm = DEFAULT_NUM_LMS;
+
+  drmModePropertyBlobRes *blob = drmModeGetPropertyBlob(fd, blob_id);
+  if (!blob) {
+    return num_lm;
+  }
+
+  const char *fmt_str = (const char *)(blob->data);
+  std::stringstream stream(fmt_str);
+  std::string line = {};
+  const std::string topology = "topology=";
+
+  while (std::getline(stream, line)) {
+    if (line.find(topology) != std::string::npos) {
+        num_lm = get_lm_number(std::string(line, topology.length()));
+        break;
+    }
+  }
+
+  drmModeFreePropertyBlob(blob);
+  return num_lm;
+}
+
 static int find_plane_prop_id(uint32_t obj_id, const char *prop_name,
                               Plane *plane_res) {
   int i, j = 0;
@@ -175,21 +239,23 @@ static int atomic_populate_plane(int plane, drmModeAtomicReqPtr atomic_req) {
   uint32_t crtc_x, crtc_y, crtc_w, crtc_h;
   int width = main_monitor_crtc->mode.hdisplay;
   int height = main_monitor_crtc->mode.vdisplay;
-
+  int zpos = 0;
   src_y = 0;
-  src_w = width/2;
+  src_w = width/number_of_lms;
   src_h =  height;
   crtc_y = 0;
-  crtc_w = width/2;
+  crtc_w = width/number_of_lms;
   crtc_h = height;
 
-  if (plane == Left) {
-    src_x = 0;
-    crtc_x = 0;
-  } else {
-    src_x = width/2;
-    crtc_x = width/2;
-  }
+  src_x = (width/number_of_lms) * plane;
+  crtc_x = (width/number_of_lms) * plane;
+
+  /* populate z-order property required for 4 layer mixer */
+  if (number_of_lms == 4)
+    zpos = plane >> 1;
+
+  atomic_add_prop_to_plane(plane_res, atomic_req,
+                           plane_res[plane].plane->plane_id, "zpos", zpos);
 
   if (atomic_add_prop_to_plane(plane_res, atomic_req,
                                plane_res[plane].plane->plane_id, "FB_ID",
@@ -237,15 +303,15 @@ static int atomic_populate_plane(int plane, drmModeAtomicReqPtr atomic_req) {
 }
 
 static int teardown_pipeline(drmModeAtomicReqPtr atomic_req) {
-  uint32_t prop_id;
-  int i, ret;
+  uint32_t i, prop_id;
+  int ret;
 
   /* During suspend, tear down pipeline */
   add_prop(&conn_res, connector, Connector, main_monitor_connector->connector_id, "CRTC_ID", 0);
   add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "MODE_ID", 0);
   add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "ACTIVE", 0);
 
-  for(i = 0; i < NUM_PLANES; i++) {
+  for(i = 0; i < number_of_lms; i++) {
     ret = atomic_add_prop_to_plane(plane_res, atomic_req,
                                    plane_res[i].plane->plane_id, "CRTC_ID", 0);
     if (ret < 0) {
@@ -267,10 +333,10 @@ static int drm_disable_crtc(drmModeAtomicReqPtr atomic_req) {
 }
 
 static int setup_pipeline(drmModeAtomicReqPtr atomic_req) {
-  uint32_t prop_id;
-  int i, ret;
+  uint32_t i, prop_id;
+  int ret;
 
-  for(i = 0; i < NUM_PLANES; i++) {
+  for(i = 0; i < number_of_lms; i++) {
     add_prop(&conn_res, connector, Connector, main_monitor_connector->connector_id,
          "CRTC_ID", main_monitor_crtc->crtc_id);
     add_prop(&crtc_res, crtc, Crtc, main_monitor_crtc->crtc_id, "MODE_ID", crtc_res.mode_blob_id);
@@ -278,7 +344,7 @@ static int setup_pipeline(drmModeAtomicReqPtr atomic_req) {
   }
 
   /* Setup planes */
-  for(i = 0; i < NUM_PLANES; i++) {
+  for(i = 0; i < number_of_lms; i++) {
     ret = atomic_populate_plane(i, atomic_req);
     if (ret < 0) {
       printf("Error populating plane_id = %d\n", plane_res[i].plane->plane_id);
@@ -450,7 +516,7 @@ static drm_surface *drm_create_surface(int width, int height) {
                               PROT_READ | PROT_WRITE, MAP_SHARED,
                               drm_fd, map_dumb.offset);
     if (surface->base.data == MAP_FAILED) {
-        perror("mmap() failed");
+        printf("mmap() failed");
         drm_destroy_surface(surface);
         return nullptr;
     }
@@ -601,7 +667,7 @@ static void disable_non_main_crtcs(int fd,
 }
 
 static void update_plane_fb() {
-  int i;
+  uint32_t i, prop_id;
 
   /* Set atomic req */
   drmModeAtomicReqPtr atomic_req = drmModeAtomicAlloc();
@@ -610,8 +676,14 @@ static void update_plane_fb() {
      return;
   }
 
+  /* Add conn-crtc association property required
+   * for driver to recognize quadpipe topology.
+   */
+  add_prop(&conn_res, connector, Connector, main_monitor_connector->connector_id,
+           "CRTC_ID", main_monitor_crtc->crtc_id);
+
   /* Add property */
-  for(i = 0; i < NUM_PLANES; i++)
+  for(i = 0; i < number_of_lms; i++)
     drmModeAtomicAddProperty(atomic_req, plane_res[i].plane->plane_id,
                              fb_prop_id, drm_surfaces[current_buffer]->fb_id);
 
@@ -695,6 +767,8 @@ static GRSurface* drm_init(minui_backend* backend __unused) {
   int width = main_monitor_crtc->mode.hdisplay;
   int height = main_monitor_crtc->mode.vdisplay;
 
+  printf("width: %d, height: %d\n", width, height);
+
   drmModeFreeResources(res);
 
   drm_surfaces[0] = drm_create_surface(width, height);
@@ -731,22 +805,26 @@ static GRSurface* drm_init(minui_backend* backend __unused) {
 
   current_buffer = 0;
 
+  drmSetClientCap(drm_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+  drmSetClientCap(drm_fd, DRM_CLIENT_CAP_ATOMIC, 1);
+
  /* Get possible plane_ids */
   drmModePlaneRes *plane_options = drmModeGetPlaneResources(drm_fd);
-  if (!plane_options)
+  if (!plane_options || !plane_options->planes || (plane_options->count_planes < number_of_lms))
     return NULL;
 
-  drmSetClientCap(drm_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
-  drmSetClientCap(drm_fd, DRM_CLIENT_CAP_ATOMIC, 1);
-
   /* Set crtc resources */
   crtc_res.props = drmModeObjectGetProperties(drm_fd,
                       main_monitor_crtc->crtc_id,
                       DRM_MODE_OBJECT_CRTC);
+
+  if (!crtc_res.props)
+    return NULL;
+
   crtc_res.props_info = static_cast<drmModePropertyRes **>
                            (calloc(crtc_res.props->count_props,
                            sizeof(crtc_res.props_info)));
-  if (!crtc_res.props || !crtc_res.props_info)
+  if (!crtc_res.props_info)
     return NULL;
   else
     for (int j = 0; j < (int)crtc_res.props->count_props; ++j)
@@ -757,24 +835,37 @@ static GRSurface* drm_init(minui_backend* backend __unused) {
   conn_res.props = drmModeObjectGetProperties(drm_fd,
                      main_monitor_connector->connector_id,
                      DRM_MODE_OBJECT_CONNECTOR);
+  if (!conn_res.props)
+    return NULL;
+
   conn_res.props_info = static_cast<drmModePropertyRes **>
                          (calloc(conn_res.props->count_props,
                          sizeof(conn_res.props_info)));
-  if(!conn_res.props || !conn_res.props_info)
+  if (!conn_res.props_info)
     return NULL;
-  else
-    for (int j = 0; j < (int)conn_res.props->count_props; ++j)
+  else {
+    for (int j = 0; j < (int)conn_res.props->count_props; ++j) {
       conn_res.props_info[j] = drmModeGetProperty(drm_fd,
                                  conn_res.props->props[j]);
 
+      /* Get preferred mode information and extract the
+       * number of layer mixers needed from the topology name.
+       */
+      if (!strcmp(conn_res.props_info[j]->name, "mode_properties")) {
+        number_of_lms = get_topology_lm_number(drm_fd, conn_res.props->prop_values[j]);
+        printf("number of lms in topology %d\n", number_of_lms);
+      }
+    }
+  }
+
   /* Set plane resources */
-  for(int i = 0; i < NUM_PLANES; ++i) {
+  for(uint32_t i = 0; i < number_of_lms; ++i) {
     plane_res[i].plane = drmModeGetPlane(drm_fd, plane_options->planes[i]);
     if (!plane_res[i].plane)
       return NULL;
   }
 
-  for (int i = 0; i < NUM_PLANES; ++i) {
+  for (uint32_t i = 0; i < number_of_lms; ++i) {
     struct Plane *obj = &plane_res[i];
     unsigned int j;
     obj->props = drmModeObjectGetProperties(drm_fd, obj->plane->plane_id,
-- 
2.47.1


From dc8b8e3c7ada2e3dcc04208879d33175fa83dc6e Mon Sep 17 00:00:00 2001
From: Mohd Faraz <androiabledroid@gmail.com>
Date: Fri, 30 Aug 2024 16:11:08 +0530
Subject: [PATCH 5/5] minuitwrp: print correct msgs

Change-Id: Ic50f02ebeb47e7b6d8ccf1d87c6281cccd7f4d01
Signed-off-by: Mohd Faraz <androiabledroid@gmail.com>
---
 minuitwrp/graphics_drm.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/minuitwrp/graphics_drm.cpp b/minuitwrp/graphics_drm.cpp
index 5628dc415..99ebd2842 100644
--- a/minuitwrp/graphics_drm.cpp
+++ b/minuitwrp/graphics_drm.cpp
@@ -380,8 +380,10 @@ static void drm_blank(minui_backend* backend __unused, bool blank) {
     ret = drmModeAtomicCommit(drm_fd, atomic_req, DRM_MODE_ATOMIC_ALLOW_MODESET, NULL);
 
   if (!ret) {
-    printf("Atomic Commit failed, rc = %d\n", ret);
+    printf("Atomic Commit succeed");
     current_blank_state = blank;
+  } else {
+    printf("Atomic Commit failed, rc = %d\n", ret);
   }
 
   drmModeAtomicFree(atomic_req);
@@ -660,7 +662,7 @@ static void disable_non_main_crtcs(int fd,
     }
     drmModeFreeCrtc(crtc);
   }
-  if (!drmModeAtomicCommit(drm_fd, atomic_req,DRM_MODE_ATOMIC_ALLOW_MODESET, NULL))
+  if (drmModeAtomicCommit(drm_fd, atomic_req,DRM_MODE_ATOMIC_ALLOW_MODESET, NULL))
     printf("Atomic Commit failed in DisableNonMainCrtcs\n");
 
   drmModeAtomicFree(atomic_req);
-- 
2.47.1

